
 namespace Encog.ML.Genetic.Genome {
	
	using Encog.ML.Genetic;
	using Encog.ML.Genetic.Population;
	using System;
	using System.Collections;
	using System.Collections.Generic;
	using System.ComponentModel;
	using System.IO;
	using System.Runtime.CompilerServices;
	using System.Runtime.Serialization;
	using System.Text;
	
	/// <summary>
	/// A basic abstract genome. Provides base functionality.
	/// </summary>
	///
	[Serializable]
	public abstract class BasicGenome : IGenome {
	
		public BasicGenome() {
			this.chromosomes = new List<Chromosome>();
			this.score = 0;
		}
	
		/// <summary>
		/// Serial id.
		/// </summary>
		///
		private const long serialVersionUID = 1L;
	
		/// <summary>
		/// The adjusted score.
		/// </summary>
		///
		private double adjustedScore;
	
		/// <summary>
		/// The amount to spawn.
		/// </summary>
		///
		private double amountToSpawn;
	
		/// <summary>
		/// The chromosomes for this gene.
		/// </summary>
		///
		private readonly IList<Chromosome> chromosomes;
	
		/// <summary>
		/// The genetic algorithm for this gene.
		/// </summary>
		///
		private GeneticAlgorithm geneticAlgorithm;
	
		/// <summary>
		/// The genome id.
		/// </summary>
		///
		private long genomeID;
	
		/// <summary>
		/// The organism generated by this gene.
		/// </summary>
		///
		private Object organism;
	
		/// <summary>
		/// The score of this genome.
		/// </summary>
		///
		private double score;
	
		/// <summary>
		/// The population this genome belongs to.
		/// </summary>
		///
		private IPopulation population;
	
		
		/// <returns>The number of genes in this genome.</returns>
		public int CalculateGeneCount() {
			int result = 0;
	
			/* foreach */
			// sum the genes in the chromosomes.
			foreach (Chromosome chromosome  in  this.chromosomes) {
				result += chromosome.Genes.Count;
			}
			return result;
		}
	
		/// <summary>
		/// 
		/// </summary>
		///
		public int CompareTo(IGenome other) {
	
			if (this.geneticAlgorithm.CalculateScore.ShouldMinimize()) {
				if (Score > other.Score) {
					return 1;
				}
				return -1;
			} else {
				if (Score > other.Score) {
					return -1;
				}
				return 1;
	
			}
		}
	
		/// <summary>
		/// Set the adjusted score.
		/// </summary>
		///
		/// <value>The score.</value>
		public double AdjustedScore {
		
		/// <returns>The adjusted score, which considers bonuses.</returns>
		  get {
				return this.adjustedScore;
			}
		/// <summary>
		/// Set the adjusted score.
		/// </summary>
		///
		/// <param name="theAdjustedScore">The score.</param>
		  set {
				this.adjustedScore = value;
			}
		}
		
	
		/// <summary>
		/// Set the amount to spawn.
		/// </summary>
		///
		/// <value>The amount to spawn.</value>
		public double AmountToSpawn {
		
		/// <returns>The amount this genome will spawn.</returns>
		  get {
				return this.amountToSpawn;
			}
		/// <summary>
		/// Set the amount to spawn.
		/// </summary>
		///
		/// <param name="theAmountToSpawn">The amount to spawn.</param>
		  set {
				this.amountToSpawn = value;
			}
		}
		
	
		
		/// <value>The number of chromosomes.</value>
		public IList<Chromosome> Chromosomes {
		
		/// <returns>The number of chromosomes.</returns>
		  get {
				return this.chromosomes;
			}
		}
		
	
		/// <summary>
		/// Set the genetic algorithm to use.
		/// </summary>
		///
		/// <value>The genetic algorithm to use.</value>
		public GeneticAlgorithm GeneticAlgorithm {
		
		/// <returns>The genetic algorithm.</returns>
		  get {
				return this.geneticAlgorithm;
			}
		/// <summary>
		/// Set the genetic algorithm to use.
		/// </summary>
		///
		/// <param name="ga">The genetic algorithm to use.</param>
		  set {
				this.geneticAlgorithm = value;
			}
		}
		
	
		/// <summary>
		/// Set the genome id.
		/// </summary>
		///
		/// <value>the genome id.</value>
		public long GenomeID {
		
		/// <returns>The genome id.</returns>
		  get {
				return this.genomeID;
			}
		/// <summary>
		/// Set the genome id.
		/// </summary>
		///
		/// <param name="theGenomeID">the genome id.</param>
		  set {
				this.genomeID = value;
			}
		}
		
	
		/// <summary>
		/// Set the organism.
		/// </summary>
		///
		/// <value>The organism.</value>
		public Object Organism {
		
		/// <returns>The organism produced.</returns>
		  get {
				return this.organism;
			}
		/// <summary>
		/// Set the organism.
		/// </summary>
		///
		/// <param name="theOrganism">The organism.</param>
		  set {
				this.organism = value;
			}
		}
		
	
		
		/// <value>the population to set</value>
		public IPopulation Population {
		
		/// <returns>the population</returns>
		  get {
				return this.population;
			}
		
		/// <param name="thePopulation">the population to set</param>
		  set {
				this.population = value;
			}
		}
		
	
		/// <summary>
		/// Set the score.
		/// </summary>
		///
		/// <value>Set the score.</value>
		public double Score {
		
		/// <returns>The score.</returns>
		  get {
				return this.score;
			}
		/// <summary>
		/// Set the score.
		/// </summary>
		///
		/// <param name="theScore">Set the score.</param>
		  set {
				this.score = value;
			}
		}
		
	
		/// <summary>
		/// Mate two genomes. Will loop over all chromosomes.
		/// </summary>
		///
		/// <param name="father">The father.</param>
		/// <param name="child1">The first child.</param>
		/// <param name="child2">The second child.</param>
		public void Mate(IGenome father, IGenome child1,
				IGenome child2) {
			int motherChromosomes = Chromosomes.Count;
			int fatherChromosomes = father.Chromosomes.Count;
	
			if (motherChromosomes != fatherChromosomes) {
				throw new GeneticError(
						"Mother and father must have same chromosome count, Mother:"
								+ motherChromosomes + ",Father:"
								+ fatherChromosomes);
			}
	
			for (int i = 0; i < fatherChromosomes; i++) {
				Chromosome motherChromosome = this.chromosomes[i];
				Chromosome fatherChromosome = father.Chromosomes[i];
				Chromosome offspring1Chromosome = child1.Chromosomes[i];
				Chromosome offspring2Chromosome = child2.Chromosomes[i];
	
				this.geneticAlgorithm.Crossover.Mate(motherChromosome,
						fatherChromosome, offspring1Chromosome,
						offspring2Chromosome);
	
				if ((new Random()).Next() < this.geneticAlgorithm.MutationPercent) {
					this.geneticAlgorithm.Mutate.PerformMutation(
							offspring1Chromosome);
				}
	
				if ((new Random()).Next() < this.geneticAlgorithm.MutationPercent) {
					this.geneticAlgorithm.Mutate.PerformMutation(
							offspring2Chromosome);
				}
			}
	
			child1.Decode();
			child2.Decode();
			this.geneticAlgorithm.PerformCalculateScore(child1);
			this.geneticAlgorithm.PerformCalculateScore(child2);
		}
	
		/// <summary>
		/// 
		/// </summary>
		///
		public sealed override  System.String ToString() {
			StringBuilder builder = new StringBuilder();
			builder.Append("[");
			builder.Append(this.GetType().Name);
			builder.Append(": score=");
			builder.Append(Score);
			return builder.ToString();
		}
	
		/// <summary>
		/// from Encog.ml.genetic.genome.Genome
		/// </summary>
		///
		public abstract void Decode();
	
		/// <summary>
		/// from Encog.ml.genetic.genome.Genome
		/// </summary>
		///
		public abstract void Encode();
	
	}
}
