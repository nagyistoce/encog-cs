/*
 * Encog(tm) Core v2.5 
 * http://www.heatonresearch.com/encog/
 * http://code.google.com/p/encog-java/
 * 
 * Copyright 2008-2010 by Heaton Research Inc.
 * 
 * Released under the LGPL.
 *
 * This is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation; either version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this software; if not, write to the Free
 * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA, or see the FSF site: http://www.fsf.org.
 * 
 * Encog and Heaton Research are Trademarks of Heaton Research, Inc.
 * For information on Heaton Research trademarks, visit:
 * 
 * http://www.heatonresearch.com/copyright.html
 */

/// ---------------------------------------------------------------------------------------------------
///  This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
///  Version 1.0.0                                                                                      
/// ---------------------------------------------------------------------------------------------------
namespace Encog.Engine.Data
{

    using System;
    using System.Collections;
    using System.Collections.Generic;
    using System.ComponentModel;
    using System.Runtime.CompilerServices;
    using System.Runtime.Serialization;

    /// <summary>
    /// Data is stored in an ArrayList. This class is memory based, so large enough
    /// datasets could cause memory issues. Many other dataset types extend this
    /// class.
    /// </summary>
    ///
    [Serializable]
    public class BasicEngineDataSet : IEngineIndexableSet
    {

        /// <summary>
        /// The serial id.
        /// </summary>
        ///
        private const long serialVersionUID = -2279722928570071183L;

        /// <summary>
        /// The data held by this object.
        /// </summary>
        ///
        private IList<IEngineData> data;

        /// <summary>
        /// Default constructor.
        /// </summary>
        ///
        public BasicEngineDataSet()
        {
            this.data = new List<IEngineData>();
        }

        /// <summary>
        /// Construct a data set from an input and idea array.
        /// </summary>
        ///
        /// <param name="input"/>The input into the neural network for training.</param>
        /// <param name="ideal"/>The ideal output for training.</param>
        public BasicEngineDataSet(double[][] input, double[][] ideal)
        {
            this.data = new List<IEngineData>();
            if (ideal != null)
            {
                for (int i = 0; i < input.Length; i++)
                {
                    double[] inputData = input[i];
                    double[] idealData = ideal[i];
                    this.Add(inputData, idealData);
                }
            }
            else
            {
                /* foreach */
                foreach (double[] element in input)
                {
                    double[] inputData_0 = element;
                    this.Add(inputData_0);
                }
            }
        }

        /// <summary>
        /// Construct a data set from an already created list. Mostly used to
        /// duplicate this class.
        /// </summary>
        ///
        /// <param name="data_0"/>The data to use.</param>
        public BasicEngineDataSet(IList<IEngineData> data_0)
        {
            this.data = new List<IEngineData>();
            this.data = data_0;
        }

        /// <summary>
        /// Add input to the training set with no expected output. This is used for
        /// unsupervised training.
        /// </summary>
        ///
        /// <param name="data_0"/>The input to be added to the training set.</param>
        public void Add(double[] d)
        {
            this.data.Add(new BasicEngineData(d));
        }

        /// <summary>
        /// Add input and expected output. This is used for supervised training.
        /// </summary>
        ///
        /// <param name="inputData"/>The input data to train on.</param>
        /// <param name="idealData"/>The ideal data to use for training.</param>
        public void Add(double[] inputData, double[] idealData)
        {

            IEngineData pair = new BasicEngineData(inputData, idealData);
            this.data.Add(pair);
        }

        /// <summary>
        /// Add a neural data pair to the list.
        /// </summary>
        ///
        /// <param name="inputData"/>A NeuralDataPair object that contains both input and idealdata.</param>
        public void Add(IEngineData inputData)
        {
            this.data.Add(inputData);
        }


        /// <param name="data_0"/>the data to set</param>
        public IList<IEngineData> Data
        {
            /// <summary>
            /// Get the data held by this container.
            /// </summary>
            ///
            /// <returns>the data</returns>
            get
            {
                return this.data;
            }

            /// <param name="data_0"/>the data to set</param>
            set
            {
                this.data = value;
            }
        }


        /// <summary>
        /// Get the size of the ideal dataset. This is obtained from the first item
        /// in the list.
        /// </summary>
        ///
        /// <returns>The size of the ideal data.</returns>
        public virtual int IdealSize
        {
            /// <summary>
            /// Get the size of the ideal dataset. This is obtained from the first item
            /// in the list.
            /// </summary>
            ///
            /// <returns>The size of the ideal data.</returns>
            get
            {
                if ((this.data.Count == 0))
                {
                    return 0;
                }
                IEngineData first = this.data[0];
                if (first.IdealArray == null)
                {
                    return 0;
                }

                return first.IdealArray.Length;
            }
        }


        /// <summary>
        /// Get the size of the input dataset. This is obtained from the first item
        /// in the list.
        /// </summary>
        ///
        /// <returns>The size of the input data.</returns>
        public virtual int InputSize
        {
            /// <summary>
            /// Get the size of the input dataset. This is obtained from the first item
            /// in the list.
            /// </summary>
            ///
            /// <returns>The size of the input data.</returns>
            get
            {
                if ((this.data.Count == 0))
                {
                    return 0;
                }
                IEngineData first = this.data[0];
                return first.InputArray.Length;
            }
        }


        /// <summary>
        /// Get a record by index into the specified pair.
        /// </summary>
        ///
        /// <param name="index"/>The index to read.</param>
        /// <param name="pair"/>The pair to hold the data.</param>
        public virtual void GetRecord(long index, IEngineData pair)
        {

            IEngineData source = this.data[(int)index];
            pair.InputArray = source.InputArray;
            if (pair.IdealArray != null)
            {
                pair.IdealArray = source.IdealArray;
            }

        }


        /// <returns>The total number of records in the file.</returns>
        public virtual long RecordCount
        {

            /// <returns>The total number of records in the file.</returns>
            get
            {
                return this.data.Count;
            }
        }


        /// <summary>
        /// Determine if this neural data set is supervied. All of the pairs should
        /// be either supervised or not, so simply check the first pair. If the list
        /// is empty then assume unsupervised.
        /// </summary>
        ///
        /// <returns>True if supervised.</returns>
        public virtual bool Supervised
        {
            /// <summary>
            /// Determine if this neural data set is supervied. All of the pairs should
            /// be either supervised or not, so simply check the first pair. If the list
            /// is empty then assume unsupervised.
            /// </summary>
            ///
            /// <returns>True if supervised.</returns>
            get
            {
                if (this.data.Count == 0)
                {
                    return false;
                }
                return this.data[0].Supervised;
            }
        }


        /// <summary>
        /// Create an additional data set. It will use the same list.
        /// </summary>
        ///
        /// <returns>The additional data set.</returns>
        public virtual IEngineIndexableSet OpenAdditional()
        {
            return new BasicEngineDataSet(this.data);
        }
    }
}
