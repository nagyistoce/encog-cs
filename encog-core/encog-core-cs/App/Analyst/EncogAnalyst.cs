/*
 * Encog(tm) Core v3.0 - Java Version
 * http://www.heatonresearch.com/encog/
 * http://code.google.com/p/encog-java/
 
 * Copyright 2008-2011 Heaton Research, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *   
 * For more information on Heaton Research copyrights, licenses 
 * and trademarks visit:
 * http://www.heatonresearch.com/copyright
 */
// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
// 5/5/11 3:32 PM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
using System;
using System.Collections.Generic;
using System.IO;
using System.Net;
using System.Runtime.CompilerServices;
using Encog.App.Analyst.Analyze;
using Encog.App.Analyst.Commands;
using Encog.App.Analyst.Script;
using Encog.App.Analyst.Script.Normalize;
using Encog.App.Analyst.Script.Prop;
using Encog.App.Analyst.Script.Task;
using Encog.App.Analyst.Wizard;
using Encog.App.Quant;
using Encog.Bot;
using Encog.ML.Train;
using Encog.Util;
using Encog.Util.Logging;

namespace Encog.App.Analyst
{
    /// <summary>
    /// The Encog Analyst runs Encog Analyst Script files (EGA) to perform many
    /// common machine learning tasks. It is very much like Maven or ANT for Encog.
    /// Encog analyst files are made up of configuration information and tasks. Tasks
    /// are series of commands that make use of the configuration information to
    /// process CSV files.
    /// </summary>
    ///
    public class EncogAnalyst
    {
        /// <summary>
        /// The name of the task that SHOULD everything.
        /// </summary>
        ///
        public const String TASK_FULL = "task-full";

        /// <summary>
        /// The update time for a download.
        /// </summary>
        ///
        public const int UPDATE_TIME = 10;

        /// <summary>
        /// The commands.
        /// </summary>
        ///
        private readonly IDictionary<String, Cmd> commands;

        /// <summary>
        /// The listeners.
        /// </summary>
        ///
        private readonly IList<AnalystListener> listeners;

        /// <summary>
        /// The analyst script.
        /// </summary>
        ///
        private readonly AnalystScript script;

        /// <summary>
        /// The current task.
        /// </summary>
        ///
        private QuantTask currentQuantTask;

        /// <summary>
        /// Holds a copy of the original property data, used to revert.
        /// </summary>
        ///
        private IDictionary<String, String> revertData;

        /// <summary>
        /// Construct the Encog analyst.
        /// </summary>
        ///
        public EncogAnalyst()
        {
            script = new AnalystScript();
            listeners = new List<AnalystListener>();
            currentQuantTask = null;
            commands = new Dictionary<String, Cmd>();
            MaxIteration = -1;
            AddCommand(new CmdCreate(this));
            AddCommand(new CmdEvaluate(this));
            AddCommand(new CmdEvaluateRaw(this));
            AddCommand(new CmdGenerate(this));
            AddCommand(new CmdNormalize(this));
            AddCommand(new CmdRandomize(this));
            AddCommand(new CmdSegregate(this));
            AddCommand(new CmdTrain(this));
            AddCommand(new CmdBalance(this));
            AddCommand(new CmdSet(this));
            AddCommand(new CmdReset(this));
            AddCommand(new CmdCluster(this));
        }

        /// <value>The lag depth.</value>
        public int LagDepth
        {
            /// <returns>The lag depth.</returns>
            get
            {
                int result = 0;

                foreach (AnalystField field  in  script.Normalize.NormalizedFields)
                {
                    if (field.TimeSlice < 0)
                    {
                        result = Math.Max(result, Math.Abs(field.TimeSlice));
                    }
                }
                return result;
            }
        }


        /// <value>The lead depth.</value>
        public int LeadDepth
        {
            /// <returns>The lead depth.</returns>
            get
            {
                int result = 0;

                foreach (AnalystField field  in  script.Normalize.NormalizedFields)
                {
                    if (field.TimeSlice > 0)
                    {
                        result = Math.Max(result, field.TimeSlice);
                    }
                }
                return result;
            }
        }


        /// <value>the listeners</value>
        public IList<AnalystListener> Listeners
        {
            /// <returns>the listeners</returns>
            get { return listeners; }
        }


        /// <summary>
        /// Set the max iterations.
        /// </summary>
        ///
        /// <value>The value for max iterations.</value>
        public int MaxIteration { /// <returns>The max iterations.</returns>
            get; /// <summary>
            /// Set the max iterations.
            /// </summary>
            ///
            /// <param name="i">The value for max iterations.</param>
            set; }


        /// <value>The reverted data.</value>
        public IDictionary<String, String> RevertData
        {
            /// <returns>The reverted data.</returns>
            get { return revertData; }
        }


        /// <value>the script</value>
        public AnalystScript Script
        {
            /// <returns>the script</returns>
            get { return script; }
        }

        /// <summary>
        /// Set the current task.
        /// </summary>
        ///
        /// <value>The current task.</value>
        public QuantTask CurrentQuantTask
        {
            /// <summary>
            /// Set the current task.
            /// </summary>
            ///
            /// <param name="task">The current task.</param>
            set { currentQuantTask = value; }
        }

        /// <value>True, if any field has a time slice.</value>
        public bool TimeSeries
        {
            /// <returns>True, if any field has a time slice.</returns>
            get
            {
                foreach (AnalystField field  in  script.Normalize.NormalizedFields)
                {
                    if (field.TimeSlice != 0)
                    {
                        return true;
                    }
                }
                return false;
            }
        }

        /// <summary>
        /// Add a listener.
        /// </summary>
        ///
        /// <param name="listener">The listener to add.</param>
        public void AddAnalystListener(AnalystListener listener)
        {
            listeners.Add(listener);
        }

        /// <summary>
        /// Add a command.
        /// </summary>
        ///
        /// <param name="cmd">The command to add.</param>
        public void AddCommand(Cmd cmd)
        {
            commands[cmd.Name] = cmd;
        }

        /// <summary>
        /// Analyze the specified file. Used by the wizard.
        /// </summary>
        ///
        /// <param name="file">The file to analyze.</param>
        /// <param name="headers">True if headers are present.</param>
        /// <param name="format">The format of the file.</param>
        public void Analyze(FileInfo file, bool headers,
                            AnalystFileFormat format)
        {
            script.Properties.SetFilename(AnalystWizard.FILE_RAW,
                                          file.ToString());

            script.Properties.SetProperty(
                ScriptProperties.SETUP_CONFIG_INPUT_HEADERS, headers);

            var a = new PerformAnalysis(script,
                                        file.ToString(), headers, format);
            a.Process(this);
        }

        /// <summary>
        /// Determine the input count.  This is the actual number of columns.
        /// </summary>
        ///
        /// <returns>The input count.</returns>
        public int DetermineInputCount()
        {
            int result = 0;

            foreach (AnalystField field  in  script.Normalize.NormalizedFields)
            {
                if (field.Input && !field.Ignored)
                {
                    result += field.ColumnsNeeded;
                }
            }
            return result;
        }

        /// <summary>
        /// Determine the input field count, the fields are higher-level 
        /// than columns.
        /// </summary>
        ///
        /// <returns>The input field count.</returns>
        public int DetermineInputFieldCount()
        {
            int result = 0;

            foreach (AnalystField field  in  script.Normalize.NormalizedFields)
            {
                if (field.Input && !field.Ignored)
                {
                    result++;
                }
            }
            return result;
        }

        /// <summary>
        /// Determine the output count, this is the number of output 
        /// columns needed.
        /// </summary>
        ///
        /// <returns>The output count.</returns>
        public int DetermineOutputCount()
        {
            int result = 0;

            foreach (AnalystField field  in  script.Normalize.NormalizedFields)
            {
                if (field.Output && !field.Ignored)
                {
                    result += field.ColumnsNeeded;
                }
            }
            return result;
        }

        /// <summary>
        /// Determine the number of output fields.  Fields are higher 
        /// level than columns.
        /// </summary>
        ///
        /// <returns>The output field count.</returns>
        public int DetermineOutputFieldCount()
        {
            int result = 0;

            foreach (AnalystField field  in  script.Normalize.NormalizedFields)
            {
                if (field.Output && !field.Ignored)
                {
                    result++;
                }
            }
            return result;
        }

        /// <summary>
        /// Determine how many unique columns there are.  Timeslices are not 
        /// counted multiple times.
        /// </summary>
        ///
        /// <returns>The number of columns.</returns>
        public int DetermineUniqueColumns()
        {
            IDictionary<String, Object> used = new Dictionary<String, Object>();
            int result = 0;


            foreach (AnalystField field  in  script.Normalize.NormalizedFields)
            {
                if (!field.Ignored)
                {
                    String name = field.Name;
                    if (!used.ContainsKey(name))
                    {
                        result += field.ColumnsNeeded;
                    }
                }
            }
            return result;
        }

        /// <summary>
        /// Determine the unique input field count.  Timeslices are not 
        /// counted multiple times.
        /// </summary>
        ///
        /// <returns>The number of unique input fields.</returns>
        public int DetermineUniqueInputFieldCount()
        {
            IDictionary<String, Object> map = new Dictionary<String, Object>();

            int result = 0;

            foreach (AnalystField field  in  script.Normalize.NormalizedFields)
            {
                if (!map.ContainsKey(field.Name))
                {
                    if (field.Input && !field.Ignored)
                    {
                        result++;
                        map[field.Name] = null;
                    }
                }
            }
            return result;
        }

        /// <summary>
        /// Determine the unique output field count.  Do not count timeslices 
        /// multiple times.
        /// </summary>
        ///
        /// <returns>The unique output field count.</returns>
        public int DetermineUniqueOutputFieldCount()
        {
            IDictionary<String, Object> map = new Dictionary<String, Object>();
            int result = 0;

            foreach (AnalystField field  in  script.Normalize.NormalizedFields)
            {
                if (!map.ContainsKey(field.Name))
                {
                    if (field.Output && !field.Ignored)
                    {
                        result++;
                    }
                    map[field.Name] = null;
                }
            }
            return result;
        }

        /// <summary>
        /// Download a raw file from the Internet.
        /// </summary>
        ///
        public void Download()
        {
            Uri sourceURL = script.Properties.GetPropertyURL(
                ScriptProperties.HEADER_DATASOURCE_SOURCE_FILE);

            String rawFile = script.Properties.GetPropertyFile(
                ScriptProperties.HEADER_DATASOURCE_RAW_FILE);

            FileInfo rawFilename = Script.ResolveFilename(rawFile);

            if (!rawFilename.Exists)
            {
                DownloadPage(sourceURL, rawFilename);
            }
        }

        /// <summary>
        /// Down load a file from the specified URL, uncompress if needed.
        /// </summary>
        ///
        /// <param name="url">THe URL.</param>
        /// <param name="file">The file to down load into.</param>
        private void DownloadPage(Uri url, FileInfo file)
        {
            try
            {
                // download the URL	
                FileStream fos = file.OpenWrite();
                int lastUpdate = 0;

                int length = 0;
                int size = 0;
                var buffer = new byte[BotUtil.BUFFER_SIZE];
                WebRequest http = WebRequest.Create(url);
                var response = (HttpWebResponse) http.GetResponse();
                Stream istream = response.GetResponseStream();

                do
                {
                    length = istream.Read(buffer, 0, buffer.Length);
                    if (length > 0)
                    {
                        if (length >= 0)
                        {
                            fos.Write(buffer, 0, length);
                            size += length;
                        }

                        if (lastUpdate > UPDATE_TIME)
                        {
                            Report(0, (int) (size/Format.MEMORY_MEG),
                                   "Downloading... " + Format.FormatMemory(size));
                            lastUpdate = 0;
                        }
                        lastUpdate++;
                    }
                } while (length > 0);


                fos.Close();
            }
            catch (IOException e)
            {
                throw new AnalystError(e);
            }
        }

        /// <summary>
        /// Execute a task.
        /// </summary>
        ///
        /// <param name="task">The task to execute.</param>
        public void ExecuteTask(AnalystTask task)
        {
            int total = task.Lines.Count;
            int current = 1;

            foreach (String line  in  task.Lines)
            {
                EncogLogging.Log(EncogLogging.LEVEL_DEBUG, "Execute analyst line: "
                                                           + line);
                ReportCommandBegin(total, current, line);

                bool canceled = false;
                String command;
                String args;

                String line2 = line.Trim();
                int index = line2.IndexOf(' ');
                if (index != -1)
                {
                    command = line2.Substring(0, (index) - (0)).ToUpper();
                    args = line2.Substring(index + 1);
                }
                else
                {
                    command = line2.ToUpper();
                    args = "";
                }

                Cmd cmd = commands[command];

                if (cmd != null)
                {
                    canceled = cmd.ExecuteCommand(args);
                }
                else
                {
                    throw new AnalystError("Unknown Command: " + line);
                }

                ReportCommandEnd(canceled);
                CurrentQuantTask = null;
                current++;

                if (ShouldStopAll())
                {
                    break;
                }
            }
        }

        /// <summary>
        /// Execute a task.
        /// </summary>
        ///
        /// <param name="name">The name of the task to execute.</param>
        public void ExecuteTask(String name)
        {
            EncogLogging.Log(EncogLogging.LEVEL_INFO, "Analyst execute task:"
                                                      + name);
            AnalystTask task = script.GetTask(name);
            if (task == null)
            {
                throw new AnalystError("Can't find task: " + name);
            }

            ExecuteTask(task);
        }


        /// <summary>
        /// Load the specified script file.
        /// </summary>
        ///
        /// <param name="file">The file to load.</param>
        public void Load(FileInfo file)
        {
            Stream fis = null;
            script.BasePath = file.DirectoryName;

            try
            {
                fis = file.OpenRead();
                Load(fis);
            }
            catch (IOException ex)
            {
                throw new AnalystError(ex);
            }
            finally
            {
                if (fis != null)
                {
                    try
                    {
                        fis.Close();
                    }
                    catch (IOException e)
                    {
                        throw new AnalystError(e);
                    }
                }
            }
        }

        /// <summary>
        /// Load from an input stream.
        /// </summary>
        ///
        /// <param name="stream">The stream to load from.</param>
        public void Load(Stream stream)
        {
            script.Load(stream);
            revertData = script.Properties.PrepareRevert();
        }

        /// <summary>
        /// Load from the specified filename.
        /// </summary>
        ///
        /// <param name="filename">The filename to load from.</param>
        public void Load(String filename)
        {
            Load(new FileInfo(filename));
        }

        /// <summary>
        /// Remove a listener.
        /// </summary>
        ///
        /// <param name="listener">The listener to remove.</param>
        public void RemoveAnalystListener(AnalystListener listener)
        {
            listeners.Remove(listener);
        }

        /// <summary>
        /// Report progress.
        /// </summary>
        ///
        /// <param name="total">The total units.</param>
        /// <param name="current">The current unit.</param>
        /// <param name="message">The message.</param>
        private void Report(int total, int current, String message)
        {
            foreach (AnalystListener listener  in  listeners)
            {
                listener.Report(total, current, message);
            }
        }

        /// <summary>
        /// Report a command has begin.
        /// </summary>
        ///
        /// <param name="total">The total units.</param>
        /// <param name="current">The current unit.</param>
        /// <param name="name">The command name.</param>
        private void ReportCommandBegin(int total, int current,
                                        String name)
        {
            foreach (AnalystListener listener  in  listeners)
            {
                listener.ReportCommandBegin(total, current, name);
            }
        }

        /// <summary>
        /// Report a command has ended.
        /// </summary>
        ///
        /// <param name="canceled">Was the command canceled.</param>
        private void ReportCommandEnd(bool canceled)
        {
            foreach (AnalystListener listener  in  listeners)
            {
                listener.ReportCommandEnd(canceled);
            }
        }

        /// <summary>
        /// Report training.
        /// </summary>
        ///
        /// <param name="train">The trainer.</param>
        public void ReportTraining(MLTrain train)
        {
            foreach (AnalystListener listener  in  listeners)
            {
                listener.ReportTraining(train);
            }
        }

        /// <summary>
        /// Report that training has begun.
        /// </summary>
        ///
        public void ReportTrainingBegin()
        {
            foreach (AnalystListener listener  in  listeners)
            {
                listener.ReportTrainingBegin();
            }
        }

        /// <summary>
        /// Report that training has ended.
        /// </summary>
        ///
        public void ReportTrainingEnd()
        {
            foreach (AnalystListener listener  in  listeners)
            {
                listener.ReportTrainingEnd();
            }
        }

        /// <summary>
        /// Save the script to a file.
        /// </summary>
        ///
        /// <param name="file">The file to save to.</param>
        public void Save(FileInfo file)
        {
            Stream fos = null;

            try
            {
                script.BasePath = file.DirectoryName;
                fos = file.OpenWrite();
                Save(fos);
            }
            catch (IOException ex)
            {
                throw new AnalystError(ex);
            }
            finally
            {
                if (fos != null)
                {
                    try
                    {
                        fos.Close();
                    }
                    catch (IOException e)
                    {
                        throw new AnalystError(e);
                    }
                }
            }
        }

        /// <summary>
        /// Save the script to a stream.
        /// </summary>
        ///
        /// <param name="stream">The stream to save to.</param>
        public void Save(Stream stream)
        {
            script.Save(stream);
        }

        /// <summary>
        /// Save the script to a filename.
        /// </summary>
        ///
        /// <param name="filename">The filename to save to.</param>
        public void Save(String filename)
        {
            Save(new FileInfo(filename));
        }


        /// <summary>
        /// Should all commands be stopped.
        /// </summary>
        ///
        /// <returns>True, if all commands should be stopped.</returns>
        private bool ShouldStopAll()
        {
            foreach (AnalystListener listener  in  listeners)
            {
                if (listener.ShouldShutDown())
                {
                    return true;
                }
            }
            return false;
        }

        /// <summary>
        /// Should the current command be stopped.
        /// </summary>
        ///
        /// <returns>True if the current command should be stopped.</returns>
        public bool ShouldStopCommand()
        {
            foreach (AnalystListener listener  in  listeners)
            {
                if (listener.ShouldStopCommand())
                {
                    return true;
                }
            }
            return false;
        }

        /// <summary>
        /// Stop the current task.
        /// </summary>
        ///
        [MethodImpl(MethodImplOptions.Synchronized)]
        public void StopCurrentTask()
        {
            if (currentQuantTask != null)
            {
                currentQuantTask.RequestStop();
            }
        }
    }
}