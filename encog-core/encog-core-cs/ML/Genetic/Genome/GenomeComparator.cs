/*
 * Encog(tm) Core v3.0 - Java Version
 * http://www.heatonresearch.com/encog/
 * http://code.google.com/p/encog-java/
 
 * Copyright 2008-2011 Heaton Research, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *   
 * For more information on Heaton Research copyrights, licenses 
 * and trademarks visit:
 * http://www.heatonresearch.com/copyright
 */
// --------------------------------------------------------------------------------------------------
// This file was automatically generated by J2CS Translator (http://j2cstranslator.sourceforge.net/). 
// Version 1.3.6.20110331_01     
// 5/5/11 3:33 PM    
// ${CustomMessageForDisclaimer}                                                                             
// --------------------------------------------------------------------------------------------------
using System;
using System.Collections.Generic;

namespace Encog.ML.Genetic.Genome
{
    /// <summary>
    /// Used to compare two genomes, a score object is used.
    /// </summary>
    ///
    public class GenomeComparator : IComparer<IGenome>
    {
        /// <summary>
        /// The method to calculate the score.
        /// </summary>
        ///
        private readonly ICalculateGenomeScore calculateScore;

        /// <summary>
        /// Construct the genome comparator.
        /// </summary>
        ///
        /// <param name="theCalculateScore">The score calculation object to use.</param>
        public GenomeComparator(ICalculateGenomeScore theCalculateScore)
        {
            calculateScore = theCalculateScore;
        }

        /// <value>The score calculation object.</value>
        public ICalculateGenomeScore CalculateScore
        {
            /// <returns>The score calculation object.</returns>
            get { return calculateScore; }
        }

        #region IComparer<IGenome> Members

        /// <summary>
        /// Compare two genomes.
        /// </summary>
        ///
        /// <param name="genome1">The first genome.</param>
        /// <param name="genome2">The second genome.</param>
        /// <returns>Zero if equal, or less than or greater than zero to indicate
        /// order.</returns>
        public int Compare(IGenome genome1, IGenome genome2)
        {
            return genome1.Score.CompareTo(genome2.Score);
        }

        #endregion

        /// <summary>
        /// Apply a bonus, this is a simple percent that is applied in the direction
        /// specified by the "should minimize" property of the score function.
        /// </summary>
        ///
        /// <param name="value">The current value.</param>
        /// <param name="bonus">The bonus.</param>
        /// <returns>The resulting value.</returns>
        public double ApplyBonus(double value_ren, double bonus)
        {
            double amount = value_ren*bonus;
            if (calculateScore.ShouldMinimize)
            {
                return value_ren - amount;
            }
            else
            {
                return value_ren + amount;
            }
        }

        /// <summary>
        /// Apply a penalty, this is a simple percent that is applied in the
        /// direction specified by the "should minimize" property of the score
        /// function.
        /// </summary>
        ///
        /// <param name="value">The current value.</param>
        /// <param name="bonus">The penalty.</param>
        /// <returns>The resulting value.</returns>
        public double ApplyPenalty(double value_ren, double bonus)
        {
            double amount = value_ren*bonus;
            if (calculateScore.ShouldMinimize)
            {
                return value_ren - amount;
            }
            else
            {
                return value_ren + amount;
            }
        }

        /// <summary>
        /// Determine the best score from two scores, uses the "should minimize"
        /// property of the score function.
        /// </summary>
        ///
        /// <param name="d1">The first score.</param>
        /// <param name="d2">The second score.</param>
        /// <returns>The best score.</returns>
        public double BestScore(double d1, double d2)
        {
            if (calculateScore.ShouldMinimize)
            {
                return Math.Min(d1, d2);
            }
            else
            {
                return Math.Max(d1, d2);
            }
        }


        /// <summary>
        /// Determine if one score is better than the other.
        /// </summary>
        ///
        /// <param name="d1">The first score to compare.</param>
        /// <param name="d2">The second score to compare.</param>
        /// <returns>True if d1 is better than d2.</returns>
        public bool IsBetterThan(double d1, double d2)
        {
            if (calculateScore.ShouldMinimize)
            {
                return d1 < d2;
            }
            else
            {
                return d1 > d2;
            }
        }
    }
}